<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <!-- Include required JS files -->
    <script type="text/javascript" src="../javascripts/shCore.js"></script>

    <!--
        At least one brush, here we choose JS. You need to include a brush for every
        language you want to highlight
    -->
    <script type="text/javascript" src="../javascripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="../javascripts/shBrushBash.js"></script>

    <!-- Include *at least* the core style and default theme -->
    <link href="../stylesheets/shCore.css" rel="stylesheet" type="text/css" />
    <link href="../stylesheets/shThemeDefault.css" rel="stylesheet" type="text/css" />


                <title>mribeirodantas's website</title>
  </head>

  <body>
    <header>
                <div class="container">
                        <h1>mribeirodantas</h1>

      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <p style="text-align:justify">O propósito desta página é documentar meus avanços na disciplina de Processamento
            Digital de Imagens no semestre letivo de 2016.1 em torno dos exercícios presentes no material disponibilizado
            pelo Prof. Dr. Agostinho Brito do Departamento de Engenharia de Computação e Automação da Universidade Federal
            do Rio Grande do Norte. Os algoritmos de solução serão escritos em C++ e a biblioteca OpenCV será exaustivamente
            utilizada.<br><br>

            O formato PNG suporta representação de imagens de diversas formas, como em tons de cinza, coloridas e preto-e-branco. Imagens em outros
            formatos tais como JPEG podem oferecer algumas limitações para os casos que serão abordados. Por exemplo, arquivos JPEG armazenam apenas
            imagens em formato colorido e, durante o processo de gravação das imagens, o algoritmo de compressão com perdas pode modificar o conteúdo
             da imagem original a ser gravada. Como a imagem que irei utilizar em alguns exemplos está em JPG, precisei convertê-la em PNG. Para isso,
             utilizei o aplicativo mogrif como é mostrado abaixo:
         <pre class="brush: bash">
             mogrify -format png barba.jpg
         </pre>
         <p style="text-align:justify">A imagem pode ser vista abaixo :-)&</p>
         <center><img src="../images/barba_despenteada.png"><br><br></center>
        <section id="exercicio1">
             <p style="text-align:justify">No <b>primeiro exercício</b>, preciso implementar um programa regions.cpp o qual deverá solicitar ao usuário as coordenadas de dois pontos P1
                 e P2 localizados dentro dos limites do tamanho da imagem. Estes pontos serão vértices opostos que darão origem a um retângulo, cujo
                 interior deverá ser o negativo da região correspondente na imagem original.<br><br>
                 O código-fonte da solução segue abaixo:</p>

            <!-- You also need to add some content to highlight, but that is covered elsewhere. -->
            <pre class="brush: cpp">
            #include &ltiostream>
            #include &ltcv.h>
            #include &lthighgui.h>
            #include &stdlib.h>

            using namespace cv;
            using namespace std;

            int main(int, char**){
              Mat image;
              cv::Size medida;
              Vec3b val;
              int p1a, p1b, p2a, p2b, altura, largura;

              image= imread("barba_despenteada.png",CV_LOAD_IMAGE_COLOR);

              medida = image.size();
              altura = medida.height;
              largura = medida.width;

              cout << "Informe as coordenadas de P1:" << endl;
              cin >> p1a;
              cin >> p1b;
              cout << "Informe a coordenada de P2:" << endl;
              cin >> p2a;
              cin >> p2b;

              if (p1a > altura) {
                  p1a = altura;
              }
              if (p2a > altura) {
                  p2a = altura;
              }
              if (p1b > largura) {
                  p1b = largura;
              }
              if (p2b > largura) {
                  p2b = largura;
              }

              val[0] = 255;   //B
              val[1] = 255;   //G
              val[2] = 255;   //R

              for(int i=p1a;i < p2a;i++){
                for(int j=p1b;j < p2b;j++){
                  image.at&ltVec3b>(i,j)= val - image.at&ltVec3b>(i,j);
                }
              }

              imshow("janela", image);
              waitKey();
              return EXIT_SUCCESS;
            }
            </pre>
            <p style="text-align:justify">Caso informássemos as coordenadas (250, 0) para o P1 e (300, 500) para o P2,
                teríamos a imagem abaixo sendo mostrada:</p>
            <center><img src="../images/tarja.png"><br><br></center>
        </section>
        <section id="exercicio2">
            <p style="text-align:justify">Para o <b>segundo exercício</b> é pedido que seja implementado um programa trocaregioes.cpp
                que deverá trocar regiões da imagem aleatoriamente, formando uma espécie de quebra-cabeças. Um dos problemas que encontrei
                é que dependendo do modo como você gera novas imagens ou copia pedaços dela você pode estar copiando partes da sua imagem já
                modifiada. Como era uma soft copy, ao passar o pedaço 2 da imagem 1 para o pedaço 1 da imagem 2, em ambas as imagens o pedaço 1
                tinha agora o pedaço 2 e isso acarretava em uma imagem final com pedaços repetidos. A linha <i>23</i> me permite fazer uma hard
                copy resolvendo esse problema. O código-fonte da solução segue abaixo:</p>
            <pre class="brush: cpp">
                #include &ltiostream>
                #include &ltcv.h>
                #include &lthighgui.h>
                #include &stdlib.h>

                using namespace cv;
                using namespace std;

                using namespace cv;

                int main(int argc, char const *argv[]) {

                  Mat image = imread("barba_despenteada.png", CV_LOAD_IMAGE_COLOR);
                  Mat image1, image2, image3, image4;

                  vector&ltMat> images;
                  random_device rd;
                  mt19937 g(rd());

                  int largura = image.rows;
                  int altura = image.cols;
                  Mat final_image(0,0, altura, largura);
                  final_image = image.clone();


                  image1 = image(Rect(altura/2, largura/2, altura/2, largura/2));
                  images.push_back(image1);
                  image2 = image(Rect(altura/2, 0, altura/2, largura/2));
                  images.push_back(image2);
                  image3 = image(Rect(0, largura/2, altura/2, largura/2));
                  images.push_back(image3);
                  image4 = image(Rect(0, 0, altura/2, largura/2));
                  images.push_back(image4);

                  shuffle(begin(images), end(images), g);
                  for (int i=0; i<4; i++) {
                      if (i==3) {
                          images[3].copyTo(final_image(Rect(0, 0, altura/2, largura/2)));
                      } else if (i==0) {
                          images[0].copyTo(final_image(Rect(altura/2, largura/2, altura/2, largura/2)));
                      } else if (i==1) {
                          images[1].copyTo(final_image(Rect(altura/2, 0, altura/2, largura/2)));
                      } else if (i==2) {
                          images[2].copyTo(final_image(Rect(0, largura/2, altura/2, largura/2)));
                      }
                  }

                  imshow("image", final_image);
                  waitKey();

                  return EXIT_SUCCESS;
                }
            </pre>
            <p style="text-align:justify">Duas imagens resultantes do algoritmo acima podem ser vistas abaixo:</p>
            <div class="images-exercicio2">
                <img src="../images/puzzle.png" float="left" border="5">
                <img src="../images/puzzl2.png" float="right" border="5">
            </div>
            <br><br>
        </section>
        <section id="exercicio3">
            <p style="text-align:justify">No <b>exercício três</b> indaga-se sobre as limitações de algoritmos de contagem de
             objetos. Em geral, um algoritmo de rotulação de imagens binárias recebe como entrada uma imagem binária e fornece
             como saída uma imagem em tons de cinza, com as várias regiões representativas de objetos rotuladas com um tom de
              cinza diferente. Fica claro que se a imagem possuir mais de 255 objetos, não teremos tons de cinza suficientes
              para representar todos os objetos. Que solução pode ser dada para essa situação?<br>
              <br>
              Como saída para esse entrave, podemos utilizar imagens de melhor resolução. 255 tons de cinza é uma limitação
              para imagens em tons de cinza de 8 bits já que 2^8 nos da 256 valores, isto é, de 0 a 255. Se tivermos imagens
               de 16 bits, por exemplo, poderemos ter até 2^16 tons, isto é, 65536 tons de cinza, o que não seria um problema
                já que os computadores de hoje lidam com palavras de 16 bits sem problemas. A resolução em 8 bits é a mais comum,
                já que um pixel é representado por um byte, mas não é incomum vermos 10, 12 ou até 16 bits em outras áreas como
                a área médica.</p>
        </section>
        <section id="exercicio4">
            <p style="text-align:justify">O <b>exercício 4</b>...</p>
        </section>
        <section id="exercicio5">
            <p style="text-align:justify">O <b>exercício 5</b> é voltado para o uso do OpenCV não mais com um fluxo estático, como uma
            imagem, mas com uma sequência de imagens, isto é, um vídeo que pode ser obtido pela sua webcam, por exemplo. Ele pede que
            equalizemos o que nossa webcam está gravando e façamos uma análise sobre os efeitos da equalização. Como em outros casos,
            o OpenCV já vem munido de algoritmos que facilitam boa parte das tarefas comuns que nos podem ocorrer no processamento
            digital de imagens. Neste caso, temos a função equalizeHist. O código-fonte segue abaixo:</p>
            <pre class="brush: cpp">
                #include "opencv2/opencv.hpp"
                #include &ltiostream>
                #include &ltstdlib.h>

                using namespace std;
                using namespace cv;

                int main(int, char**){

                    VideoCapture cap(0);


                    if(!cap.isOpened())
                        return -1;

                    namedWindow("Imagem de vídeo", 1);

                    while(1) {
                        Mat frame;
                        vector&ltMat> planes;
                        cap >> frame;
                        split (frame, planes);
                        Mat B,G,R;

                        //Equaliza as componeste separadamente
                        equalizeHist(planes[0], B);
                        equalizeHist(planes[1], G);
                        equalizeHist(planes[2], R);


                        vector&ltMat> combined;

                        combined.push_back(B);
                        combined.push_back(G);
                        combined.push_back(R);


                        Mat result;


                        merge(combined,result);

                        imshow("Video equalizado", result);
                        imshow("Video", frame);

                        if(waitKey(30) >= 0) break;
                    }

                      return EXIT_SUCCESS;
                }
            </pre>
            <p style="align-text:justify">É possível ver a diferença nas filmagens pelo printscreen abaixo:</p>
            <img src="../images/eq.png" float="left" border="5">
        </section>
        <section id="exercicio6">
            <p style="align-text:justify">No <b>exercício seis</b> </p>
        </section>

      </section>

    </div>
        <br>
        <center>
                <img src="../gnu.png" alt="GNU" width="90" height="120">
                <h5>Copyright ®  2016 <a href="http://mribeirodantas.fedorapeople.org" target="_blank">Marcel Ribeiro Dantas</a></h5>
                <h6>Content managed with vim</h6>
        </center>
  </body>
  <!-- Finally, to actually run the highlighter, you need to include this JS on your page -->
  <script type="text/javascript">
    SyntaxHighlighter.all()
  </script>
</html>
